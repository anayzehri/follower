<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eye Tracking Dot Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #f0f0f0;
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        #gameContainer {
            position: relative;
            width: 80vw;
            height: 80vh;
            background-color: #fff;
            border: 1px solid #ccc;
            overflow: hidden;
        }

        #dot {
            position: absolute;
            width: 50px;
            height: 50px;
            background-color: blue;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none; /* Prevent the dot from interfering with clicks */
            transition: top 0.5s ease-in-out, left 0.5s ease-in-out, background-color 0.2s ease-in-out, width 0.3s ease-in-out, height 0.3s ease-in-out;
        }

        #score {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 20px;
        }

        #calibrationInstructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 255, 255, 0.8);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 10;
        }

        #calibrationPoint {
            width: 15px;
            height: 15px;
            background-color: red;
            border-radius: 50%;
            position: absolute;
            transform: translate(-50%, -50%);
            cursor: pointer;
        }

        #startButton {
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 255, 255, 0.9);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
        }

        #gameOver button {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }

        #level {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 20px;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="dot"></div>
        <div id="score">Score: 0</div>
        <div id="level">Level: 1</div>
        <div id="calibrationInstructions">
            <h1>Calibration</h1>
            <p>Please stare at the red dots as they appear on the screen.</p>
            <div id="calibrationPoints"></div>
            <button onclick="calibrate()">Start Calibration</button>
        </div>
        <div id="gameOver" class="hidden">
            <h1>Game Over!</h1>
            <p>Your final score: <span id="finalScore"></span></p>
            <button id="restartButton">Play Again</button>
        </div>
    </div>
    <button id="startButton" class="hidden">Start Game</button>

    <script src="webgazer.js"></script>
    <script>
        // --- Game State ---
        let score = 0;
        let level = 1;
        let isTracking = false;
        let gameActive = false;
        let dotSpeed = 1.5; // Base speed multiplier
        let dotSize = 50;
        let gazeHistory = [];
        const gazeHistoryLength = 5; // Number of recent gaze points to average
        const gazeThreshold = 70; // Maximum distance for considering the gaze on the dot
        let calibrationPoints = [];
        let calibrationIndex = 0;
        const numberOfCalibrationPoints = 5;

        // --- DOM Elements ---
        const gameContainer = document.getElementById('gameContainer');
        const dotElement = document.getElementById('dot');
        const scoreElement = document.getElementById('score');
        const levelElement = document.getElementById('level');
        const calibrationInstructions = document.getElementById('calibrationInstructions');
        const calibrationPointsContainer = document.getElementById('calibrationPoints');
        const startButton = document.getElementById('startButton');
        const gameOverScreen = document.getElementById('gameOver');
        const finalScoreElement = document.getElementById('finalScore');
        const restartButton = document.getElementById('restartButton');

        // --- WebGazer Initialization ---
        webgazer.setGazeListener(function(data, elapsedTime) {
            if (data == null || !gameActive) return;
            gazeHistory.push({x: data.x, y: data.y});
            if (gazeHistory.length > gazeHistoryLength) {
                gazeHistory.shift();
            }
        }).begin();
        webgazer.showPredictionPoints(false); // Hide default prediction points

        // --- Helper Functions ---
        function getRandomPosition() {
            const containerRect = gameContainer.getBoundingClientRect();
            const dotRect = dotElement.getBoundingClientRect();
            const maxX = containerRect.width - dotRect.width;
            const maxY = containerRect.height - dotRect.height;
            const x = Math.random() * maxX;
            const y = Math.random() * maxY;
            return { x, y };
        }

        function moveDot(x, y) {
            dotElement.style.left = x + 'px';
            dotElement.style.top = y + 'px';
        }

        function isLookingAtDot(gazeX, gazeY) {
            if (!gazeX || !gazeY) return false;
            const dotRect = dotElement.getBoundingClientRect();
            const dotCenterX = dotRect.left + dotRect.width / 2;
            const dotCenterY = dotRect.top + dotRect.height / 2;
            const distance = Math.sqrt(Math.pow(gazeX - dotCenterX, 2) + Math.pow(gazeY - dotCenterY, 2));
            return distance < gazeThreshold;
        }

        function averageGaze() {
            if (gazeHistory.length === 0) return null;
            let sumX = 0;
            let sumY = 0;
            for (const gaze of gazeHistory) {
                sumX += gaze.x;
                sumY += gaze.y;
            }
            return { x: sumX / gazeHistory.length, y: sumY / gazeHistory.length };
        }

        // --- Game Logic ---
        function updateGame() {
            if (!gameActive) return;

            const avgGaze = averageGaze();
            if (avgGaze) {
                const isLooking = isLookingAtDot(avgGaze.x, avgGaze.y);
                if (isLooking && !isTracking) {
                    isTracking = true;
                    dotElement.style.backgroundColor = 'green';
                } else if (!isLooking && isTracking) {
                    isTracking = false;
                    dotElement.style.backgroundColor = 'blue';
                }

                if (isLooking) {
                    score++;
                    scoreElement.textContent = `Score: ${score}`;
                }
            }

            requestAnimationFrame(updateGame);
        }

        function moveDotRandomly() {
            if (!gameActive) return;
            const newPosition = getRandomPosition();
            moveDot(newPosition.x, newPosition.y);
            const moveInterval = Math.max(100, 2000 / (dotSpeed * level)); // Increase speed with level
            setTimeout(moveDotRandomly, moveInterval);
        }

        function increaseDifficulty() {
            if (!gameActive) return;
            level++;
            levelElement.textContent = `Level: ${level}`;
            if (level % 2 === 0) {
                dotSpeed *= 1.1; // Increase speed
            }
            if (level % 3 === 0) {
                dotSize = Math.max(20, dotSize - 5); // Decrease size
                dotElement.style.width = `${dotSize}px`;
                dotElement.style.height = `${dotSize}px`;
            }
            setTimeout(increaseDifficulty, 10000); // Increase difficulty every 10 seconds
        }

        function startGame() {
            gameActive = true;
            score = 0;
            level = 1;
            dotSpeed = 1.5;
            dotSize = 50;
            isTracking = false;
            scoreElement.textContent = `Score: ${score}`;
            levelElement.textContent = `Level: ${level}`;
            gameOverScreen.classList.add('hidden');
            startButton.classList.add('hidden');
            dotElement.style.width = `${dotSize}px`;
            dotElement.style.height = `${dotSize}px`;
            dotElement.style.backgroundColor = 'blue';
            moveDotRandomly();
            updateGame();
            increaseDifficulty();
        }

        function endGame() {
            gameActive = false;
            finalScoreElement.textContent = score;
            gameOverScreen.classList.remove('hidden');
        }

        // --- Calibration ---
        function createCalibrationPoint(x, y, index) {
            const point = document.createElement('div');
            point.id = `calibrationPoint-${index}`;
            point.classList.add('calibrationPoint');
            point.style.left = x + 'px';
            point.style.top = y + 'px';
            point.style.position = 'absolute';
            point.style.width = '15px';
            point.style.height = '15px';
            point.style.backgroundColor = 'red';
            point.style.borderRadius = '50%';
            point.style.transform = 'translate(-50%, -50%)';
            point.style.cursor = 'pointer';
            point.onclick = function() {
                webgazer.collectData(1);
                calibrationIndex++;
                if (calibrationIndex < numberOfCalibrationPoints) {
                    showCalibrationPoint();
                } else {
                    calibrationInstructions.classList.add('hidden');
                    startButton.classList.remove('hidden');
                }
            };
            calibrationPointsContainer.appendChild(point);
        }

        function showCalibrationPoint() {
            calibrationPointsContainer.innerHTML = ''; // Clear previous points
            const containerRect = gameContainer.getBoundingClientRect();
            const points = [
                { x: containerRect.width * 0.2, y: containerRect.height * 0.2 },
                { x: containerRect.width * 0.8, y: containerRect.height * 0.2 },
                { x: containerRect.width * 0.5, y: containerRect.height * 0.5 },
                { x: containerRect.width * 0.2, y: containerRect.height * 0.8 },
                { x: containerRect.width * 0.8, y: containerRect.height * 0.8 }
            ];
            createCalibrationPoint(points[calibrationIndex].x, points[calibrationIndex].y, calibrationIndex);
        }

        function calibrate() {
            calibrationIndex = 0;
            calibrationInstructions.classList.remove('hidden');
            startButton.classList.add('hidden');
            showCalibrationPoint();
        }

        // --- Event Listeners ---
        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', calibrate);

        // --- Initial Setup ---
        // Calibration will start on page load
    </script>
</body>
</html>
