<!DOCTYPE html>
<html>
<head>
    <title>The Follower</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }

        #game-container {
            position: relative;
            margin-top: 20px;
        }

        canvas {
            border: 2px solid #333;
            background-color: #fff;
        }

        #controls {
            margin-top: 10px;
            display: flex;
            gap: 10px;
        }

        #score {
            margin-top: 10px;
            font-size: 1.2em;
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            font-size: 2em;
            text-align: center;
            display: none;
        }

        #initialization-message {
            margin-bottom: 10px;
            color: orange;
        }

        #tracking-status {
            margin-top: 10px;
            font-size: 0.9em;
            color: green;
        }

        #error-message {
            margin-top: 10px;
            color: red;
            font-weight: bold;
            display: none;
        }
    </style>
</head>
<body>
    <h1>The Follower</h1>

    <div id="initialization-message">Initializing eye tracking...</div>
    <div id="error-message"></div>

    <div id="game-container">
        <canvas id="gameCanvas" width="600" height="400"></canvas>
        <div id="game-over">Game Over</div>
    </div>

    <div id="controls">
        <button id="startButton" disabled>Start Game</button>
        <button id="calibrateButton">Calibrate</button>
    </div>

    <div id="score">Score: 0</div>
    <div id="tracking-status"></div>

    <script src="https://webgazer.cs.brown.edu/webgazer.js"></script>
    <script>
        // Get DOM elements
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        if (ctx) {
            ctx.willReadFrequently = true;
        }
        const startButton = document.getElementById('startButton');
        const calibrateButton = document.getElementById('calibrateButton');
        const scoreDisplay = document.getElementById('score');
        const gameOverDisplay = document.getElementById('game-over');
        const initializationMessage = document.getElementById('initialization-message');
        const trackingStatusDisplay = document.getElementById('tracking-status');
        const errorMessageDisplay = document.getElementById('error-message');

        // Game variables
        let target = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            radius: 20,
            color: 'blue',
            speed: 2,
            dx: 1,
            dy: 1
        };
        let gazeX = null;
        let gazeY = null;
        let score = 0;
        let trackingRadius = 50;
        let isTracking = false;
        let gameOver = false;
        let noTrackTimer = 0;
        const gameOverTime = 1; // seconds
        let gameInterval;
        let difficultyLevel = 1;

        // Gaze Smoothing Variables
        const smoothingFactor = 0.3; // Adjust for more or less smoothing

        // Initialize WebGazer
        webgazer.setGazeListener(function(data, elapsedTime) {
            if (data == null) {
                return;
            }

            // Apply smoothing
            gazeX = gazeX === null ? data.x : gazeX + smoothingFactor * (data.x - gazeX);
            gazeY = gazeY === null ? data.y : gazeY + smoothingFactor * (data.y - gazeY);
        }).begin()
        .catch(function(err) {
            initializationMessage.style.display = 'none';
            errorMessageDisplay.textContent = 'Failed to initialize WebGazer. Make sure you have a webcam and have granted permissions.';
            errorMessageDisplay.style.display = 'block';
        });
        webgazer.showPredictionPoints(true); // Optional: Show the raw prediction points

        webgazer.on('ready', function() {
            initializationMessage.style.display = 'none';
            startButton.disabled = false;
            calibrateButton.disabled = false;
        });

        webgazer.on('calibration_started', function() {
            initializationMessage.textContent = 'Calibration started. Please look at the targets.';
            initializationMessage.style.display = 'block';
        });

        webgazer.on('calibration_finished', function(success) {
            initializationMessage.style.display = 'none';
            if (success) {
                alert('Calibration successful!');
            } else {
                alert('Calibration failed. Please try again.');
            }
        });

        // Function to draw the target
        function drawTarget() {
            ctx.beginPath();
            ctx.arc(target.x, target.y, target.radius, 0, Math.PI * 2);
            ctx.fillStyle = target.color;
            ctx.fill();
            ctx.closePath();
        }

        // Function to draw the gaze indicator
        function drawGaze() {
            if (gazeX !== null && gazeY !== null) {
                ctx.beginPath();
                ctx.arc(gazeX, gazeY, 10, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0, 255, 0, 0.8)'; // Green, slightly transparent
                ctx.fill();
                ctx.closePath();
            }
        }

        // Function to draw the tracking radius
        function drawTrackingRadius() {
            ctx.beginPath();
            ctx.arc(target.x, target.y, trackingRadius, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)'; // Yellow, semi-transparent
            ctx.stroke();
            ctx.closePath();
        }

        // Function to move the target
        function moveTarget() {
            target.x += target.dx * target.speed * difficultyLevel;
            target.y += target.dy * target.speed * difficultyLevel;

            // Bounce off the edges
            if (target.x + target.radius > canvas.width || target.x - target.radius < 0) {
                target.dx *= -1;
            }
            if (target.y + target.radius > canvas.height || target.y - target.radius < 0) {
                target.dy *= -1;
            }
        }

        // Function to check if the player is tracking the target
        function checkTracking() {
            if (gazeX !== null && gazeY !== null) {
                const distance = Math.sqrt((gazeX - target.x) ** 2 + (gazeY - target.y) ** 2);
                if (distance < trackingRadius) {
                    if (!isTracking) {
                        trackingStatusDisplay.textContent = 'Tracking!';
                        target.color = 'green'; // Visual feedback
                        isTracking = true;
                    }
                    return true;
                } else {
                    if (isTracking) {
                        trackingStatusDisplay.textContent = '';
                        target.color = 'blue';
                        isTracking = false;
                    }
                    return false;
                }
            }
            return false;
        }

        // Function to update the score
        function updateScore() {
            scoreDisplay.textContent = `Score: ${Math.floor(score)}`;
        }

        // Function to increase difficulty
        function increaseDifficulty() {
            if (Math.floor(score) > 50 && difficultyLevel === 1) {
                difficultyLevel = 1.5;
                target.color = 'orange';
            } else if (Math.floor(score) > 150 && difficultyLevel === 1.5) {
                difficultyLevel = 2;
                target.color = 'red';
            }
            // Add more difficulty levels as needed
        }

        // Game over function
        function endGame() {
            clearInterval(gameInterval);
            gameOver = true;
            gameOverDisplay.style.display = 'block';
            startButton.disabled = false;
            calibrateButton.disabled = false;
            startButton.textContent = 'Play Again';
        }

        // Main game loop
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawTrackingRadius(); // Draw the tracking radius
            moveTarget();
            drawTarget();
            drawGaze();

            if (checkTracking()) {
                score += 0.1;
                noTrackTimer = 0;
            } else {
                noTrackTimer += 1/60; // Assuming 60 FPS
                if (noTrackTimer >= gameOverTime) {
                    endGame();
                }
            }

            updateScore();
            increaseDifficulty();

            if (!gameOver) {
                requestAnimationFrame(draw);
            }
        }

        // Start game function
        function startGame() {
            gameOver = false;
            score = 0;
            target.x = canvas.width / 2;
            target.y = canvas.height / 2;
            target.speed = 2;
            target.color = 'blue';
            difficultyLevel = 1;
            noTrackTimer = 0;
            gameOverDisplay.style.display = 'none';
            startButton.disabled = true;
            calibrateButton.disabled = true;
            startButton.textContent = 'Start Game'; // Reset button text
            trackingStatusDisplay.textContent = '';

            // Reset target direction randomly
            target.dx = Math.random() > 0.5 ? 1 : -1;
            target.dy = Math.random() > 0.5 ? 1 : -1;

            draw();
        }

        // Calibrate button click handler
        calibrateButton.addEventListener('click', function() {
            webgazer.clearData();
            webgazer.startCalibration();
            // You can optionally add more steps or visual cues here during calibration
        });

        // Event listener for the start button
        startButton.addEventListener('click', startGame);
    </script>
</body>
</html>
