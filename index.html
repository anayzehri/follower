<!DOCTYPE html>
<html>
<head>
    <title>Gaze Breaker</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: sans-serif;
        }

        #gameCanvas {
            background-color: #ddd;
            cursor: none; /* Hide the default cursor */
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
        }

        #scoreDisplay {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 20px;
            color: #333;
        }
    </style>
</head>
<body>
    <div id="scoreDisplay">Score: 0</div>
    <canvas id="gameCanvas"></canvas>
    <div id="gameOver">
        <h1>Game Over!</h1>
        <p>Your Score: <span id="finalScore">0</span></p>
        <button onclick="startGame()">Play Again</button>
    </div>

    <script src="https://webgazer.cs.brown.edu/webgazer.js" defer></script>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameOverScreen = document.getElementById('gameOver');
        const finalScoreDisplay = document.getElementById('finalScore');
        const scoreDisplay = document.getElementById('scoreDisplay');

        let dot = {
            x: 0,
            y: 0,
            radius: 10,
            color: 'blue'
        };
        let gazeX = -100; // Initialize off-screen
        let gazeY = -100;
        let fixationTime = 1000; // 1 second
        let isFixating = false;
        let fixationStartTime = 0;
        let score = 0;
        let gameActive = false;
        let lastDotMoveTime = 0;
        let dotMoveInterval = 2000; // Move dot every 2 seconds
        let dotMoveSpeedIncreaseInterval = 10000; // Increase speed every 10 seconds
        let dotMoveSpeedIncreaseFactor = 0.9;
        let wave = 1;

        // --- Visual Presentation Variables ---
        let backgroundColor = '#f0f0f0';
        let backgroundAnimationTimer = 0;
        const backgroundAnimationSpeed = 0.001; // Adjust for speed

        // --- Gameplay Progression & Difficulty Variables ---
        let dotBaseRadius = 10;
        let dotMinRadius = 5;
        let dotRadiusChangeChance = 0.05; // Chance of dot size changing
        let dotRadiusChangeFactor = 2;

        // --- Interesting Mechanics & Twists Variables ---
        let phantomDots = [];
        const maxPhantomDots = 5;
        const phantomDotSpawnChance = 0.01;
        const phantomDotLifespan = 500; // Milliseconds

        // --- Feedback Variables ---
        let nearMissThreshold = 50; // Distance for near miss
        let lastNearMissTime = 0;
        const nearMissCooldown = 500; // Prevent rapid near miss triggers

        // --- WebGazer Calibration ---
        window.onload = function() {
            webgazer.setGazeListener(function(data, elapsedTime) {
                if (data == null) {
                    return;
                }
                gazeX = data.x;
                gazeY = data.y;
            }).begin();
            webgazer.showPredictionPoints(true); // Show the predicted gaze point (for debugging)
        };

        function startGame() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gameOverScreen.style.display = 'none';
            score = 0;
            wave = 1;
            dot.radius = dotBaseRadius;
            dotMoveInterval = 2000;
            gameActive = true;
            moveDot();
            lastDotMoveTime = performance.now();
            lastDotMoveSpeedIncreaseTime = performance.now();
            phantomDots = [];
            loop();
        }

        function moveDot() {
            dot.x = Math.random() * (canvas.width - 2 * dot.radius) + dot.radius;
            dot.y = Math.random() * (canvas.height - 2 * dot.radius) + dot.radius;
            dot.color = getRandomColor(); // Change color each move
        }

        function getRandomColor() {
            const colors = ['blue', 'green', 'purple', 'orange', 'cyan'];
            return colors[Math.floor(Math.random() * colors.length)];
        }

        function checkFixation() {
            if (!gameActive) return;

            const distance = Math.sqrt((gazeX - dot.x) ** 2 + (gazeY - dot.y) ** 2);

            if (distance < dot.radius) {
                if (!isFixating) {
                    isFixating = true;
                    fixationStartTime = performance.now();
                } else if (performance.now() - fixationStartTime >= fixationTime) {
                    endGame();
                }
            } else {
                isFixating = false;
                // Near miss feedback
                if (distance < dot.radius + nearMissThreshold && performance.now() - lastNearMissTime > nearMissCooldown) {
                    // Visual cue for near miss (briefly change background color)
                    backgroundColor = 'rgba(255, 255, 0, 0.5)';
                    lastNearMissTime = performance.now();
                }
            }
        }

        function updateScore() {
            if (gameActive) {
                score++;
                scoreDisplay.textContent = `Score: ${score}`;
            }
        }

        function updateDifficulty() {
            if (performance.now() - lastDotMoveSpeedIncreaseTime >= dotMoveSpeedIncreaseInterval) {
                dotMoveInterval *= dotMoveSpeedIncreaseFactor;
                if (dot.radius > dotMinRadius && Math.random() < dotRadiusChangeChance) {
                    dot.radius = Math.max(dotMinRadius, dot.radius / dotRadiusChangeFactor);
                } else if (Math.random() < dotRadiusChangeChance) {
                    dot.radius *= dotRadiusChangeFactor;
                }
                lastDotMoveSpeedIncreaseTime = performance.now();
                wave++;
            }
        }

        function spawnPhantomDot() {
            if (phantomDots.length < maxPhantomDots && Math.random() < phantomDotSpawnChance) {
                phantomDots.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    radius: Math.random() * 5 + 5,
                    alpha: 1,
                    spawnTime: performance.now()
                });
            }
        }

        function updatePhantomDots() {
            phantomDots = phantomDots.filter(pd => performance.now() - pd.spawnTime < phantomDotLifespan);
            phantomDots.forEach(pd => {
                pd.alpha = 1 - (performance.now() - pd.spawnTime) / phantomDotLifespan;
            });
        }

        function drawPhantomDots() {
            phantomDots.forEach(pd => {
                ctx.beginPath();
                ctx.arc(pd.x, pd.y, pd.radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(200, 200, 200, ${pd.alpha})`;
                ctx.fill();
            });
        }

        function endGame() {
            gameActive = false;
            finalScoreDisplay.textContent = score;
            gameOverScreen.style.display = 'flex';
            webgazer.pause(); // Optionally pause WebGazer
        }

        function drawDot() {
            ctx.beginPath();
            ctx.arc(dot.x, dot.y, dot.radius, 0, Math.PI * 2);
            ctx.fillStyle = dot.color;
            ctx.fill();
        }

        function drawGaze() {
            ctx.beginPath();
            ctx.arc(gazeX, gazeY, 5, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 0, 0, 0.5)'; // Semi-transparent red for gaze
            ctx.fill();
        }

        function updateBackground() {
            backgroundAnimationTimer += backgroundAnimationSpeed;
            const shade = Math.sin(backgroundAnimationTimer) * 5 + 245; // Oscillating shade
            backgroundColor = `rgb(${shade}, ${shade}, ${shade})`;
        }

        function loop() {
            if (!gameActive) return;

            requestAnimationFrame(loop);

            updateBackground();
            canvas.style.backgroundColor = backgroundColor;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            updatePhantomDots();
            drawPhantomDots();

            drawDot();
            // drawGaze(); // Uncomment to see the gaze point

            checkFixation();
            updateScore();
            updateDifficulty();
            spawnPhantomDot();

            // Move the dot periodically
            if (performance.now() - lastDotMoveTime >= dotMoveInterval) {
                moveDot();
                lastDotMoveTime = performance.now();
            }

            // Reset near miss background color
            if (backgroundColor.startsWith('rgba(255, 255, 0') && performance.now() - lastNearMissTime > nearMissCooldown) {
                backgroundColor = '#f0f0f0';
            }
        }

        // Start the game when the page loads
        startGame();
    </script>
</body>
</html>
